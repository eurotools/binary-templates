//------------------------------------------------
//--- 010 Editor v11.0.1 Binary Template
//
//      File: SpyroSoundBanks.bt
//   Authors: jmarti856, Swyter
//   Version: 1.0
//   Purpose: Parse SFX soundbanks files.
//  Category: Audio
// File Mask: *_sb_*.sfx
//  ID Bytes: 4D 55 53 58
//------------------------------------------------
 
//*===============================================================================================
//* Typedefs for the sfx file
//*===============================================================================================
typedef char Padding[2];

//*===============================================================================================
//* DEFINE STRUCTS USED IN THE SFX FILE
//*===============================================================================================
//The first parameters of the header are always little endian
LittleEndian(); local int sfxIsBigEndian = 0;

typedef struct 
{
    char   Magic[4];
    uint   Hashcode<format=hex>;
    uint   ConstantOffset<format=hex>;
    uint   FileSize <format=hex>;
	char   Platform[4];
	uint   TimeSpan;
	uint   unk;
	uint   structPadding;

	if (ReadUInt() != 0x0800) /* For GC */
	{
        Printf("[i] This is a GameCube SFX. Changing endianness to big-endian.");
        BigEndian(); sfxIsBigEndian = 1;
	}
} CommonHeader <read=Str("[%s] %#010x | %s", Magic, Hashcode, Platform)>;

typedef struct
{
	uint	SFXStart<format=hex>;
	uint 	SFXLength;
	uint 	SampleInfoStart<format=hex>;
	uint	SampleInfoLength;
	uint	SpecialSampleInfoStart<format=hex>;
	uint	SpecialSampleInfoLength;
	uint	SampleDataStart<format=hex>;
	uint	SampleDataLength;
} SoundBanksHeader;

typedef struct
{
	uint	HashCode<format=hex>;
	uint 	Location<format=hex>;
} SoundsArray;

struct Group
{ 
    short GroupHashCode : 4;
    short GroupMaxChannels : 12; 
};

typedef struct
{
	short 	DuckerLength;
	short 	MinDelay;
	short 	MaxDelay;
	ubyte	ReverbSend;
	ubyte 	TrackingType;
	ubyte	MaxVoices;
	ubyte	Priority;
	ubyte	Ducker;
	ubyte 	MasterVolume;
	struct  Group GroupSettings;
	short   Flags;
	short	SamplesCount;

    typedef	struct
    {
	    short FileRef;
	    short PitchOffset;
	    short RandomPitchOffset;
	    ubyte BaseVolume;
	    ubyte RandomVolumeOffset;
	    ubyte Pan;
	    ubyte RandomPan;
	    Padding SectPadding;
    } Samples;

    SetBackColor(cAqua);
	Samples smpParams[SamplesCount];

} Sounds;



typedef struct
{
	uint 	Flags;
	uint	Address;
	uint 	AudioDataSize<format=hex>;
	uint 	Frequency;
	uint 	RealSize;
	uint	PSI;
	uint	LoopOffset;
	uint	Duration;
} SampleInfo;

typedef struct
{
	uint NumSamples;
	uint NibblesADPCM;
	uint SampleRate;
	ushort LoopFlag;
	ushort Format;
	uint StartOffset;
	uint EndOffset;
	uint unk;
	ushort DecodeCoefficients[16]<format=hex>;
	ushort Gain;
	ushort Predictor;
	ushort SampleHistory;
	ushort SampleHistory2;
	ushort PredictorLoop;
	ushort SampleHistoryLoop;
	ushort SampleHistoryLoop2;
	ushort PaddingSamples[10];
	ushort padding;
} SpecialSample;

//*===============================================================================================
//* READ FILE
//*===============================================================================================
// Define the headers
SetBackColor(cLtPurple);
CommonHeader header;

// Check for valid header
if(header.Magic != "MUSX")
{
    Warning( "File is not a valid SFX file. Template stopped." );
    return -1;
}

// Read Soundbanks Header
SetBackColor(cGreen);
SoundBanksHeader SBHeader;

//Go to SFXStart pos
if (FSeek( SBHeader.SFXStart ) < 0)
{
	Warning( "Error searching the SFX start position");
	return -1;
}

//Get the number of stored sounds in this section
uint totalSounds;

SetBackColor(cBlue);
SoundsArray StoredSound[totalSounds];

//Read SFX Array & SFX Params
local int index = 0;
local long currentPos = 0;

for (index = 0; index < totalSounds; index++)
{
	FSeek(StoredSound[index].Location + SBHeader.SFXStart);
    SetBackColor(cLtRed);
	Sounds sfxParams;
}

//Read Sample Info Section
if (FSeek( SBHeader.SampleInfoStart ) < 0)
{
	Warning( "Error searching the sample info start position");
	return -1;
}

//Get the number of stored samples in this section
uint totalSamples;

//Read samples params
index = 0;
for (index = 0; index < totalSamples; index++)
{
	SetBackColor(cLtGreen);
    SampleInfo sampleInfoParams;
	currentPos = FTell();
	
	FSeek(sampleInfoParams.Address + SBHeader.SampleDataStart);
	SetBackColor(cDkRed);
	struct {byte audioData[sampleInfoParams.AudioDataSize]; } a;
	FSeek(currentPos);
}

//Read Special Sample Info Section
if (SBHeader.SampleInfoStart != SBHeader.SpecialSampleInfoStart)
{
	if (FSeek(SBHeader.SpecialSampleInfoStart ) < 0)
	{
		Warning( "Error searching the special sample info start position");
		return -1;
	}
	
	local int totalSpecialSamples = SBHeader.SpecialSampleInfoLength / sizeof(SpecialSample);
	index = 0;
	for (index = 0; index < totalSpecialSamples; index++)
	{
		SetBackColor(cLtGreen);
		SpecialSample specialInfo;
	}
}